
"""Final_part_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OC_xcKHSRmCM03U6FZpEF9Z3wUgO2yUb

**O(logN) Algorithm**

**Binary Search Algorithm:**

* Initialize a low variable pointing to the first index of the array
* Initialize a high variable pointing to the last index of the array
* Repeat the following steps while low is less than or equal to high:

    * Calculate the mid point as (low + high) // 2 (integer division)

    * Compare the target value with the value at the mid index:
    * If the target value equals the value at the mid point, return mid
    * If the target value is larger than the value at the mid point, update low to be mid + 1
    * If the target value is less than the value at the mid point, update high to be mid * 1
* If the loop ends without finding target value, return -1
"""

def binary_search(array, target):
  low, high = 0, len(array) - 1
  while low <= high:
    mid = (low + high) // 2
    if target == array[mid]:
      return mid
    elif target > array[mid]:
      low = mid + 1
    else:
      high = mid - 1
  return -1

binary_search([1,2,3,4,5,6,7,8], 2)

"""Analysis of Binary Search Algorithm:

    f(n) = 2 + (n/2 * 1/2 * 1/2 * 1/2...) + 1

    f(n) = 3 + n/2^k

    n = 2^k

    log2 n = log2 2^k

    log2 n = K log2 2

    k = log2 n ==> O(log2 N)

**O(N logN) Algorithm**

**Merge Sort Algorithm:**

* If the array's length is 0 or 1, return the array as is

* Calculate the midpoint of the array

* Slice the array into two sub-arrays, left & right around midpoint

* Recursively call Merge Sort function on both left & right sub-arrays

* Invoke the Merge function with left & right arrays as arguments

Merge Function:

* Declare a new empty array

* Declare two counters, initialized to 0

* Iterate while both counters are less than the lengths of the left and right arrays:

   * Compare the elements of left and right arrays at the same position

   * Append the smaller value to the new array

   * Increment the counter of the array that the element was appended from

* After the loop, extend the new array with the remaining elements from both arrays.

* Return the new array.
"""

def merge_sort(array):
  if len(array) <= 1:
    return array
  mid = len(array) // 2
  right_array = array[mid:]
  left_array = array[:mid]
  left = merge_sort(left_array)
  right = merge_sort(right_array)

  return merge(left, right)

def merge(left, right):
  new_array = []
  i, j = 0, 0
  while i < len(left) and j < len(right):
    if left[i] <= right[j]:
      new_array.append(left[i])
      i += 1
    else:
      new_array.append(right[j])
      j += 1
  new_array.extend(left[i:])
  new_array.extend(right[j:])
  return new_array

"""Analysis of Merge Sort Algorithm:

           { 1  , n <= 1 }
    T(n) =

           { n + (T(n/2) + T(n/2))  , n > 1}

           T(n)
           / \
     T(n/2)   T(n/2)
         /      \
     T(n/4)    T(n/4)
        /         \
     T(n/8)    T(n/8)

    n * T(n/2^k) = n * T(k * log2 n)
    n * T(k * log2 n) = n * T(k) * (log2 n)

    T(n) = n * log2(n) * T(k)
    O(n log n)

**O(n) Algorithm:**

**In-order/ Pre-order and Post-Order Tree Traversal Algorithms:**



*  check if the node is not None
*  call function recursively on the left subtree for the node
*  print current node value
*  call function recursively on the right subtree for the node
"""

class Node:
  def __init__(self, value):
    self.value = value
    self.left = None
    self.right = None

class Tree:
  def __init__(self, node):
    self.node = node

def traverse_tree(node):
  if node is None:
    return
  traverse_tree(node.left)
  print(node.value)
  traverse_tree(node.right)

root = Node(2)
tree = Tree(root)
root.left = Node(3)
root.right = Node(4)
root.left.left = Node(5)
root.left.right = Node(6)

traverse_tree(root)

"""Analysis of Tree Traversal Algorithm:

          { 1, node = None }
    T(node) =
          {T(node.left) + T(node.right) + 1, node!=None}

            T(n)
            / \
    T(n.left)   T(n.right)
          /        \
    T(n.left.left)  T(n.right.right)
        /             \

    T(n) = T(n)/2 + T(n)/2 + 1

    T(n) = 2 T(n) / 2 + 1 = T(n) + 1

    O(n)

**O(n^2) Algorithm:**

**Brute Force Algorithm:**
 Find All Occurrences of a Pattern in a Text

*   create an empty list for indexes results
*   loop over the length of the text and up to the length of the pattern inclusive
*   create a boolean initialized to True
*   create an inner loop that loops for the length of the pattern
*   checking if the characters at positions i+j in the text and j in the pattern donot match => set match variable to False and break from inner loop
*   if inner loop completes and match is True, push i to the results list
"""

def find_pattern(text, pattern):
  indexes = []
  text_length = len(text)
  pattern_length = len(pattern)

  for i in range(0, text_length - pattern_length + 1):
    match = True
    for j in range(pattern_length):
      if text[i+j] != pattern[j]:
        match = False
        break
    if match:
      indexes.append(i)
  return indexes

find_pattern("abcdbbabcd", "abcd")

"""Analysis of Brute force Algorithm:

    f(n) = 3 + (n-k+1)*(4k) + 1

    f(n) = 3 + 4nk - 4k^2 + 4k + 1

    f(n) = 4kn - 4k^2 + 4k + 4

    O(n^2)  
"""